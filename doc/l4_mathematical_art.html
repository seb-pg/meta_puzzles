<!DOCTYPE html>
<html>
<head>
<title>Mathematical Art – solution explanation</title>
</head>
<body>

<h1>Mathematical Art – solution explanation</h1>

The problem is composed of two separate problems:
<ul>
    <li>Create segments from input data</li>
    <li>Merging overlapping segments</li>
    <li>Counting crosses for the merged overlapping segments</li>
</ul>

<h2>Merging overlapping segments sub-problem in O(n*log(n)):</h2>
The algorithm used is similar to the “<a href="https://en.wikipedia.org/wiki/Shadow_volume">shadow volume</a>” algorithm in computer graphics.<br>
<br>
Assuming horizontal segment (y, x0, x1) sharing the same y coordinate, where x0 < x1, the algorithm is as follow...<br>
<br>
For each segment opening (x0), we assign a value of -1 -> (x0, -1).<br>
For each segment closing (x1), we assign a value of +1 -> (x1, +1).<br>
We create an array with those pairs, and we sorted it.<br>
<br>
Parsing the area from left to right (smallest x to higher x), we accumulate the pairs’ second value:<br>
<ul>
    <li>Any value below 0 means we have more opening than closing (we are inside a merge segment), and</li>
    <li>the value of 0 means we are outside a segment (so, we the value is zero, were store the merged segment).</li>
    <li>values above zero are not possible here</li>
</ul>

Without assuming anything on how the segments are built and assuming all segments are on the same line:<br>
<ul>
<li>Time Complexity: O(n*log(n))</li>
<li>Space Complexity: O(n)</li>
</ul>

<h2>Counting crosses for the merged overlapping segments in O(n*n)</h2>
Assuming with have an array for vertical segments, and an array for horizontal segments (n elements at most).<br>
A trivial algorithm in O(n*n) would be for each vertical segments in O(n), test which horizontal segments are crossing in O(n).<br>

<br>
In this case, the complexity is:
<ul>
<li>Time Complexity: O(n*log(n))</li>
<li>Space Complexity: O(1)</li>
</ul>

<h2>Counting crosses for the merged overlapping segments in O(n*log(n))</h2>

<h3>The algorithm aims to be able to the following test:</h3>h3>
For a given vertical segment (x, y0, y1) where y0 < y1 (blue segment in the image below),<br>
We have an ordered collection of horizontal segments (y[i], x0[i], x1[i]), sorted by y where x0[i] < x < x1[i] (red and green segment in the image below)<br>
<br>
For an ordered set, we can use two binary search to find:
<ul>
    <li>which first horizontal segment crosses the vertical line (bottom green line), and</li>
    <li>which last horizontal segment crosses the vertical line (top green line)</li>
</ul>

<img src="l4_mathematical_art1.png">
<br>
Should it be possible to maintain efficiently such an ordered set, we would have our log(n).

<h3>Algorithm used</h3>
We can transform the inner loop our previous algorithm to achieve this result, by maintaining two ordered lists:
<ul>
    <li>one list for the left side of horizontal strokes (opening),</li>
    <li>one list for the right side of the horizontal strokes (closing).</li>
</ul>

When a new vertical segment is tested (remember: they are ordered by x), we:
<ul>
    <li>add the heights of the segments where x0[i] < x (the start of the segment added is on the left of the vertical line being tested)</li>
    <li>removed the heights of the segment where x1[i] <= x (the end of the segment removed is on the right or ends on the vertical line being tested)</li>
</ul>
Note: As the segment are merge, the heights are unique.

Should it be possible to maintain efficiently such an ordered set, we would have our log(n).<br>
<br>
In this case, the complexity is:
<ul>
<li>Time Complexity: O(n*log(n))</li>
<li>Space Complexity: O(n)</li>
</ul>

</body>
</html>
